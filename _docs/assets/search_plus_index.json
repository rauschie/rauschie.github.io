{"/jekyll-gitbook/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/about/",
    "body": "This is an about page."
  },"/jekyll-gitbook/pages/contact/": {
    "title": "Contact",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/contact/",
    "body": "This is an contact page."
  },"/jekyll-gitbook/pages/design/draft/": {
    "title": "Design Draft",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/pages/design/draft/",
    "body": "This is an draft page."
  },"/jekyll-gitbook/jekyll/2022-06-30-tips_warnings_dangers.html": {
    "title": "Tips, Warnings, and Dangers",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-06-30-tips_warnings_dangers.html",
    "body": "The jekyll-theme supports tips, warnings, and dangers blocks and the style is referred from the discord.js website. You could have the following markdown attributes (supported by kramdown): Tips Using a {: .block-tip} attribute: &gt; ##### TIP &gt; &gt; This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have &gt; this or a similar version after installation. {: .block-tip } TIP This guide is last tested with @napi-rs/canvas^0.1.20, so make sure you have this or a similar version after installation. Warnings Using a {: .block-warning} attribute: &gt; ##### WARNING &gt; &gt; Be sure that you're familiar with things like async/await and object destructuring &gt; before continuing, as we'll be making use of features like these. {: .block-warning } WARNING Be sure that you‚Äôre familiar with things like async/await and object destructuring before continuing, as we‚Äôll be making use of features like these. Dangers Using a {: .block-danger} attribute: &gt; ##### DANGER &gt; &gt; You cannot delete an ephemeral message. {: .block-danger } DANGER You cannot delete an ephemeral message."
  },"/jekyll-gitbook/jekyll/2022-05-24-page_cover.html": {
    "title": "Page with cover image",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2022-05-24-page_cover.html",
    "body": "The jekyll-gitbook theme supports adding a cover image to a specific page by adding a cover field to the page metadata: --- title: Page with cover image author: Tao He date: 2022-05-24 category: Jekyll layout: post + cover: /assets/jekyll-gitbook/dinosaur.gif ---"
  },"/jekyll-gitbook/jekyll/2019-04-29-license.html": {
    "title": "License",
    "keywords": "Jekyll",
    "url": "/jekyll-gitbook/jekyll/2019-04-29-license.html",
    "body": "This work is open sourced under the Apache License, Version 2.0, using the same license as the original GitBook repository. Copyright 2019 Tao He."
  },"/jekyll-gitbook/1970-01-30-glossary.html": {
    "title": "Glossary",
    "keywords": "",
    "url": "/jekyll-gitbook/1970-01-30-glossary.html",
    "body": "operator //TODO a function. Often used as a shorthand for 'binary operator', which takes two things of one type and combines them into a single thing of same type, so they lend themselves well for infix notation. A set being 'closed' under an operation makes intuitive sense then: given only elements of a set and such an operator, you can't express anything isomorph for the current intents and purposes, the same. type constructor a type with one or more holes that you can plug another types into, like EventHandler&lt;E&gt; or Map&lt;K,V&gt;. Since it is a type in itself, you can consider it as an encoding of a type level function. type level function a function that operates on a given language‚Äôs types. //TODO"
  },"/jekyll-gitbook/1970-01-05-programs.html": {
    "title": "3. Writing actual programs",
    "keywords": "",
    "url": "/jekyll-gitbook/1970-01-05-programs.html",
    "body": "Type constuctors ‚Äì Abstracting over (side-)effects We‚Äôve shown how expressing our programs in terms of pure functions is extremely beneficial for composability and correctness, however, we are asking a lot of today‚Äôs programs. They have to operate over networks, across multiple processors, often on spotty data and can have ridiculously complex dependencies. At this point it is still unclear, how pure functions can encode such computational contexts. In this chapter, we are introducing an essential construct that can be used to abstract away the most common effects, that obfuscate variables. Some of those are: not being readily available or available at all, needing external dependencies or needing a plan B if things go seriously wrong (throwing Exceptions). An intro: the ‚ÄúMaybe‚Äù type Given $\\mathbb{A}:$ any type expressible by the type system you can define: $Maybe(\\mathbb{A}) := \\mathbb{A}\\bigsqcup()$ ‚Äì where $()$ denotes the empty set. We aren‚Äôt picking the empty set because it‚Äôs empty, but because it is agreed that every set contains it. It serves as the bottom type, a type that is a subtype of all other types. You might ask what‚Äôs in the empty set and your answer is right: nothing. Types like never, Nothing or null can be used to encode exactly that notion. A value of type $Maybe(\\mathbb{A})$ is then either an $\\mathbb{A}$ or nothing. Typescript rust scala java üöß enum Option&lt;T&gt; { None, Some(T), } sealed abstract class Option[+A] case object None extends Option[Nothing] case class Some[A] extends Option[A] üöß //TODO code matching example Monads ‚Äì encoding the notion: ‚ÄúAnd $then$‚Äù The type $Maybe$, together with two operations defined over it is an example of a monad. The monad is a construct that lets us encapsulate some side effect and takes the form of some type constructor $M()$. We‚Äôll call the first associated operation ‚Äò$then$‚Äô. $\\cdot \\mathbin{then} \\cdot: (Maybe(\\mathbb{A}), \\mathbb{A} \\Rightarrow Maybe(\\mathbb{B}))\\Rightarrow Maybe(\\mathbb{B})$ The notation is a bit tense at first but what this operator does is allowing you to chain any number of functions together that return a $Maybe$. given: $getUserByEmail: \\mathbb{String} \\Rightarrow Maybe(\\mathbb{User})$ $getActiveSessionByUser: \\mathbb{U}ser \\Rightarrow Maybe(\\mathbb{S}ession)$ $getCartContentBySession: \\mathbb{S}ession \\Rightarrow Maybe(\\mathbb{C}artItems)$ you can define: $getCartContentByEmail: \\mathbb{S}tring \\Rightarrow Maybe(\\mathbb{C}artItems)$ $= getUserByEmail \\mathbin{then} (getActiveSessionByUser \\mathbin{then} (getCartContentBySession))$ the operator $then$ runs by a number of aliases, including flatMap, pipe, &gt;&gt;=, the latter pronounced as ‚Äú[monadic] bind‚Äù Typescript rust scala java üöß let get_user_by_email : FnOnce(&amp;str) -&gt; Option&lt;User&gt;, ... get_user_by_email(\"me@hooli.com\") .and_then(get_active_session_by_user) .and_then(get_cart_content_by_session) //TODO var getUserByEmail: String =&gt; Option[User] ... getUserByEmail(\"me@hooli.com\") .flatMap(_.activeSession) .flatMap(_.cartContent) üöß Let‚Äôs stop and ponder for a second on what we just did here. Monad laws Left- and right identity Associativity List ‚Äì I don‚Äôt care, how many times Many languages implement $flatMap$ over a collection, offering an alternative for nested loops. The most often cited example is the linked list though, since it can be nicely described in a functional way: $List(\\mathbb{A}):= Cons(\\mathbb{A}) \\bigsqcup Nil$ $Nil: List(())$ $Cons(\\mathbb{A}) := \\mathbb{A} \\times List(\\mathbb{A})$ $\\cdot \\mathbin{::}\\cdot = (head: \\mathbb{A}, tail: List(\\mathbb{A})) \\Rightarrow Cons(\\mathbb{A}) \\\\ = head :: tail \\mapsto (head, tail)$ if you then write: foo$\\mathbin{::}$bar$\\mathbin{::}$baz$\\mathbin{::}Nil$ type Nil = List&lt;Nothing&gt; type Cons&lt;A&gt; = { head: A tail: List&lt;A&gt; } type List&lt;A&gt; = Cons&lt;A&gt; | Nil Typescript rust scala üöß üöß sealed abstract class List[+A] case class ::[+A](head: A, tail:List[+A]) extends List[A] case object Nil extends List[Nothing] Functor ‚Äì a relaxed monad $flatMap:= flatten \\circ map$ associativity of flatmap ==&gt; you can collapse the effect ==&gt; no matter how deep you nest the effect $Maybe$, at the end, you will be left with a value or nothing. //TODO Either ‚Äì Complex error handling IO ‚Äì Asynchronous computations Reader ‚Äì Dependency injection"
  },"/jekyll-gitbook/1970-01-04-rules.html": {
    "title": "2. The rules ‚Äì reasoning about state",
    "keywords": "",
    "url": "/jekyll-gitbook/1970-01-04-rules.html",
    "body": "Function application is referentially transparent Every occurence of $f(x)$, in any context, always evaluates to the same thing. In computer science, functions exhibiting this property are called ‚Äòpure‚Äô, and going forward, as we say ‚Äòfunction‚Äô, we always mean a pure function. This is in contrast with some similar constructs like methods or procedures, which might have side effects (effectively reassign $x$ or any other value, making it ambiguous), warranting a distinction. You can totally not expect two occurences of $raiseSalary(\\text{employee})$ to evaluate to the same thing, as opposed to $getId(\\text{user})$. Writing programs that don‚Äôt break referential transparency too badly, and how that makes life easy is an important theme of the following chapters. Functions compose Given the above $f$ and an arbitrary $g \\in (\\mathbb{N} \\Rightarrow \\mathbb{Z})$ there‚Äôs nothing stopping you from defing $h \\in (\\mathbb{N} \\Rightarrow \\mathbb{Q})$ in terms of $f$ and $g$. \\[h:=x \\mapsto f(g(x))\\] As long as the domain of $f$ matches the codomain of $g$, it‚Äôs perfectly fine to say ‚Äò$f$ of $g$ of $x$‚Äô and $h$ is a well-defined symbol. Function composition is associative We can use the following symbol to denote functon composition: $\\displaylines{ \\cdot\\circ\\cdot:(\\mathbb{B} \\Rightarrow \\mathbb{C})\\times(\\mathbb{A} \\Rightarrow \\mathbb{B}) \\Rightarrow (\\mathbb{A} \\Rightarrow \\mathbb{C}) \\\\ =(g \\circ f)(x:\\mathbb{A}) \\mapsto g(f(x)) }$ //TODO let your programs compose like functions the operator ‚Äú$\\circ$‚Äù (read: ‚Äúafter‚Äù) is a function over the set of functions. Furthermore, it is an associative one. That means that the order of application does not matter, the expressions ‚Äú$(h\\mathbin{\\text{after}}g)\\mathbin{\\text{after}}f$‚Äù and ‚Äú$h\\mathbin{\\text{after}}(g\\mathbin{\\text{after}}f)$‚Äù have the same meaning. Pipe you can also trivially define the well-known $pipe$ operator, often denoted with |: $\\cdot \\mathbin{pipe} \\cdot:(x:\\mathbb{A}, f: \\mathbb{A} \\Rightarrow \\mathbb{B}) \\Rightarrow \\mathbb{B} = x \\mathbin{pipe} f \\mapsto f(x)$, where $\\mathbb{B}:=$ the codomain of $f$. We like this one a lot, as it helps a great deal with readibility ‚Äì the order in which functions are applied now matches their order of appearance in the source code, ie //TODO do away with db due to async connotation $ (getCartContents \\circ getUserByEmail \\circ getDbHandle)()$ then becomes: getDbHandle() | getUserByEmail | getCartContent"
  },"/jekyll-gitbook/1970-01-03-tooling.html": {
    "title": "1. The tooling - functions and types",
    "keywords": "",
    "url": "/jekyll-gitbook/1970-01-03-tooling.html",
    "body": "We‚Äôve been talking about data, operations and chaining instructions - intuitively the concept of a function that one has become familiar with during school years, seems like something that could be of interest here. Let‚Äôs reiterate what that is and what extremely useful properties it has. Sets $x: \\mathbb{z}$ ‚Äì Let x be an element of $\\mathbb{Z}$. $\\mathbb{Z}$ is a set. In typed programming languages, expressions are assigned a type. You can think of types as sets. c scala java int x; val x: Int Integer x; Anatomy of a function They have to do with two kinds of data: the kind they can be applied to, and the kind they spew out. You can describe one like this: \\[f:\\mathbb{Z} \\Rightarrow \\mathbb{Q} = x \\mapsto \\frac{x}{2}\\] where $f$ is the symbol by which the function is referenced, $\\mathbb{Z}$ is the set of things $f$ is applicable to, and the expression on the right hand side maps any element $x$ of $\\mathbb{Z}$ to exactly one thing of type $\\mathbb{Q}$. $f(x)$ - read: ‚Äò$f$ of $x$‚Äô is then called the image of $x$ under $f$. The term $\\mathbb{Z} \\Rightarrow \\mathbb{Q}$ denotes the set of functions that map from $\\mathbb{Z}$ to $\\mathbb{Q}$. The set of functions is indeed a thing, thus we will encounter functions that operate on other functions, return them, or both. Note that in order for the expression $f(x)$ to make sense, both the symbols $f$ and $x$ have to be unambiguous, the practical implication being that you can‚Äôt reassign them. //TODO Set operators ‚Äì Algebraic data types The notion of a function is quite closely coupled to that of a set, you define one in terms of its domain and codomain. Two operations over sets are of fundamental interest: they enable us to clearly define what data our function can access and what shape of data it outputs. Algebraic data types are the way functional programs model the world and represent state - they are a notion just as fundamental as classes are for OOP. Given some axiomatic types ‚Äì think: primitives, they enable you to represent arbitrarily complex data. Product type aka tuple, record, struct $\\mathbb{A}\\times\\mathbb{B}$ ‚ÄÉ‚Äì an element from $\\mathbb{A}$ $and$ one from $\\mathbb{B}$. A $\\mathbb{U}$sername an an $\\mathbb{I}$d. $\\mathbb{B}$read and $\\mathbb{B}$utter. The deeply familiar construct used to bunch up a couple of things that just go together. If you‚Äôve ever seen a tuple, struct or even a class (forget methods though ‚Äìsetters especially), you already have a great intuition about what it does. You‚Äôd want to use it for all the usual reasons, like grouping data points that don‚Äôt make sense without each other or outputting multiple values. Typescript rust scala java interface User = { email: string, id: number, } struct User{ email: String, id: u64, } case class User(email: String, id: Long) record User(String email, Long id){} It gives us a trivial way to extend the capabilities of the function costruct: it is now capable of taking on any finite number of arguments that can be expressed via our type system, as well as outputting structured data. Given: $\\mathbb{U}ser:=\\mathbb{S}tring \\times \\mathbb{L}ong $ //TODO Encoding fun() For all intents and purposes, you can always substitute an n-ary function $f:(x \\in \\mathbb{A}, y \\in \\mathbb{B}, ‚Ä¶, i \\in \\mathbb{I}) \\Rightarrow \\mathbb{Z}$ for an unary one, taking a product: $f:(\\mathbb{A}\\times\\mathbb{B}\\times ‚Ä¶ \\times \\mathbb{I}) \\Rightarrow \\mathbb{Z}$ a perhaps bit lesser-known trick is to substitute for a chain of unary functions, each returning an unary function taking the next member of the product: $f:(\\mathbb{A})\\Rightarrow(\\mathbb{B})\\Rightarrow ‚Ä¶ \\Rightarrow (\\mathbb{I}) \\Rightarrow \\mathbb{Z}$ you would then apply $f$ like this: $z:\\mathbb{Z} = f(x)(y)‚Ä¶(i)$ The third form is called a Curried function. Sum type aka disjoint union, tagged union, coproduct \\(\\mathbb{A}\\bigsqcup\\mathbb{B}\\), sometimes: $\\mathbb{A}+\\mathbb{B}$ ‚ÄÉ‚Äì an element from $\\mathbb{A}$ $or$ from $\\mathbb{B}$. Typescript rust scala type Pet = Cat | Dog enum Pet { Cat, Dog, } sealed trait Pet case class Cat() extends Pet case class Dog() extends Pet Pattern matching You have at some point likely encountered something like this function: $f: = (x : \\mathbb{R}) \\mapsto \\begin{cases} 1 &amp;\\text{if } (x) \\in \\mathbb{Q} \\\\ 0 &amp;\\text{else} \\end{cases} $ //TODO ad-hoc polymorphism Key takeaways If you read ‚ÄúType‚Äù, think: ‚ÄúSet‚Äù If you see ‚Äú:‚Äù, think: ‚Äú$\\in$‚Äù If you read ‚ÄúProduct type‚Äù, think: ‚Äú$and$‚Äù, ‚ÄúStruct‚Äù, ‚ÄúTuple‚Äù, even: ‚ÄúClass‚Äù If you read ‚ÄúSum type‚Äù, think: ‚Äú$or$‚Äù, ‚ÄúEnum‚Äù, ‚ÄúTraits‚Äù or whatever construct your language choses to encode this type-level operator with Optional reading Top-, Bottom- and Unit types Top type ~ a supertype of all types. Any. Unit type ~ any singleton type really. Point is, that if it serves as the codomain of a pure function, all the elements of the domain can only map to a single element in the codomain, thus all pure functions mapping a given type to the unit type are equal. Bottom type ~ a subtype of all types. Nothing. A side note on etymology The terms ‚Äúsum-‚Äú and ‚Äúproduct type‚Äù reflect on the observation that the number of elements in the cartesian product and disjoint union, denoted $|\\mathbb{A}\\times\\mathbb{B}|$ and $|\\mathbb{A}\\bigsqcup\\mathbb{B}|$, equals that of $|\\mathbb{A}| \\cdot |\\mathbb{B}|$ and $|\\mathbb{A}|\\ + |\\mathbb{B}|$ respectively. //TODO verify milewski Over some type systems, these operators also work analoguosly to multiplication and addition over a semiring. Category theory has the concept of a ‚Äúdual construct‚Äù, which is then called co-$CONSTRUCT, and the disjoint union being the dual of the product in that framework, is termed ‚Äúcoproduct‚Äù."
  },"/jekyll-gitbook/1970-01-02-problem.html": {
    "title": "The Problem",
    "keywords": "",
    "url": "/jekyll-gitbook/1970-01-02-problem.html",
    "body": "One may choose to look at computer programs as a sequence of instructions, ie some operations carried out on some data. Since the outcome of any instruction depends on all the other instructions carried out before it, the name of the game soon became finding approaches that let humans reason about the correctness of these instructions - given out by the billions every second on modern hardware. We want to make sure that we do the right operations, on the right data, in the right order. Functional programming is one of those approaches, and this post tries to give a very high level overview of what it is about."
  },"/jekyll-gitbook/1970-01-01-foreword.html": {
    "title": "Foreword",
    "keywords": "",
    "url": "/jekyll-gitbook/1970-01-01-foreword.html",
    "body": "This guide is intended for those who already have some familiarity with writing code and seeks to provide a somewhat comprehensive overview on the essence of functional programming. It is not meant to teach functional techniques in any specific language, but includes snippets in multiple of them. The intent is to develop the intuition that the constructs discussed here are fundamentally valid independently of language limitations, as well as to help with terminology: many of these are referenced differently depending on whether the exchange is specific to a language. One of the goals is to provide a path through this tutorial with the least possible amount of meta. I am striving to only introduce notions that ‚Äúpull their own weight‚Äù ‚Äì either have direct practical applications, or are directly necessary for those that have direct applications, or provide entry points to topics hat //TODO."
  }}
